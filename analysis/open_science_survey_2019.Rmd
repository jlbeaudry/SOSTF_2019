---
title: "Swinburne Open Science Task Force Survey (2019)"
author: "Jennifer L Beaudry, Tom Johnstone, Jordy Kaufman & Lisa Given"
date: '`r format (Sys.time(), "%d %B %Y")`'
output:
  #word_document: 
   # fig_width: 10 # this works, but it changes the font of plot_ly, etc.
   # fig_height: 12 # so, don't use for now
  html_document: default 
  #pdf_document: default # this works now [but margin issues around plot_ly]
always_allow_html: true # true for word; false for pdf (?)
csl: apa-old-doi-prefix.csl
bibliography: Beaudry_Library.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align= "center")
options(scipen = 999)
options(kableExtra.auto_format = TRUE) 
# If I knit as a word doc:
  # switch auto_format to 'false'; 'true' for pdf or html
  # add 'fig.width = 8, fig.height = 8' to opts_chunk 

# If knit as a pdf or html:
# switch auto_format to 'true' 
# include width and height parameters in the plot_ly function
  #  width = 300, 
  #  height = NULL,
  # along with all other parameters
# need to also figure out how to modify the margins (maybe the orca package or 
  # maybe the webshot settings? More research needed.)
```


```{r library, include=FALSE}
# load the library
library(tinytex)
library(knitr)
library(here)
library(plyr)
library(tidyverse)
library(skimr)
library(ggbeeswarm)
library(plotly)
library(RColorBrewer)
library(kableExtra)
```

```{r function_defs, include=FALSE}
# define functions here

## CALCULATE PERCENTAGES ##

perc <- function (x,y){  #x = variable; #y = n of valid cases
  c <- plyr::count (x)         #frequencies per level
  round (100*(c [,2] / y), 0) #rounding to 0 decimal places   
}

## PIE CHART ##

# Tom's to-do list
    # open-ended data to Lisa...
    # Tom to try to round to integer
    # change y-axis & include parameter, which will change the data: done
    # add in ability to order according to different criteria (labels or coded number): added order by response order. Still to add order by number of responses.
 
simple_pie_chart <- function (the_data, label_var="", the_title="", colours, order = "ByRespNum", the_quantity = "", include_NA = "NO"){

  # the column with the response item numbers
  item_var = paste(label_var,"_num",sep="")
  
  # if including NAs, replace with "no response"
  # and set position of "no response" on graph (e.g., "FIRST" or "LAST")
  if (include_NA != "NO") {
    the_data[[label_var]][is.na(the_data[[label_var]])] <- "No response"
    the_data[[item_var]][is.na(the_data[[item_var]])] <- switch(include_NA,
                                                                FIRST = 0,
                                                                LAST = max(the_data[[item_var]])+1)
  }  
 
  # filter out non-responses
  the_data <- the_data[ !is.na(the_data[[label_var]]),]
  
  # calculate number of rows with a valid response 
  nvalid <- nrow(the_data)
  
  # tally the responses for each response option
  pie_data <- plyr::count(the_data,vars=c(label_var,item_var))
  
  # sort the data by response option order (needs other sort orders added)
  if (order == "ByRespNum") pie_data <- pie_data[order(pie_data[[item_var]]),]
  
  # by default display counts
  the_textinfo <- 'label+value'
  the_text = ""
  # display percentages if specified
  if (the_quantity == "percent") {
    pie_data$perc <- paste(as.character(round(100*pie_data$freq/nvalid)),"%",sep="")
    the_textinfo <- 'label+text'
    the_text <- pie_data$perc
  }  
  
  # insert total number of responses into the title text
  the_title = sprintf(the_title,nvalid)
  
  # Create the pie chart
  p <- plot_ly(pie_data, labels = pie_data[[label_var]], values = pie_data$freq, type = 'pie',
               textposition = "inside",
               textinfo = the_textinfo,
               text = the_text,
               marker = list(colors = colours, line=list(color="white", width=6)),
               showlegend = FALSE,
               sort = FALSE,
               direction = "clockwise",
               rotation = 0,
               hole = 0.25,
               pull = 0,
               title = list 
                  (text = the_title, position = "top center",font = list (size=20, color="black")))
  return(p)
}


## BAR CHART HISTOGRAM ##

simple_bar_graph <- function (the_data, label_var = "", the_title = "", 
                              yname = "Count", xname = "Response",
                              bar_colour = "blue",line_colour = "",line_width = 1, include_NA = "NO", order = "ByRespNum", the_quantity = ""){

  # the column with the response item numbers
  item_var = paste(label_var,"_num",sep="")
  
  # if including NAs, replace with "no response"
  # and set position of "no response" on graph
  if (include_NA != "NO") {
    the_data[[label_var]][is.na(the_data[[label_var]])] <- "No response"
    the_data[[item_var]][is.na(the_data[[item_var]])] <- switch(include_NA,
                                                                FIRST = 0,
                                                                LAST = max(the_data[[item_var]])+1)
  }  
  
  # filter out NAs
  the_data <- the_data[ !is.na(the_data[[label_var]]),]
  
  # calculate number of rows with a valid response 
  nvalid <- nrow(the_data)
  
  # tally the responses for each response option
  bar_data <- plyr::count(the_data,vars=c(label_var,item_var))
  
  # sort the data by response option order (needs other sort orders added)
  if (order == "ByRespNum") bar_data <- bar_data[order(bar_data[[item_var]]),]
  
  # by default display counts
  the_column <- "freq"
  yname <- "number of responses"
  # display percentages if specified
  if (the_quantity == "percent") {
    bar_data$perc <- 100*bar_data$freq/nvalid
    the_column <- "perc"
    yname <- "percent of responses"
  }  
  
  # insert total number of responses into the title text
  the_title = sprintf(the_title,nvalid)
  
  # create labels for the graph elements
  qtext <- "What is your experience with open materials and/or code?"
  
  if (line_colour == "") line_width <- 0
  # create the plot
  p <- plot_ly(
    x = bar_data[[label_var]],
    y = bar_data[[the_column]],
    type = "bar",
    orientation="v",
    marker = list(color = bar_colour,
                           line = list(color = line_colour, width = line_width))) %>%
    layout (title = the_title, 
            yaxis = list (title=yname), 
            xaxis = list (title=xname,type="category",categoryorder="trace"))
  return(p)
}

 ### META RENAME ####

meta_rename <-  function(df, metadata, old, new) {
  
  keys   <- metadata[[deparse(substitute(old))]]
  values <- metadata[[deparse(substitute(new))]]
  rename_at(df, vars(keys), ~ values)
}

```

```{r import data, include=FALSE}
#import the data. Here I'm using the original Qualtrics data, rather than Jordy's revised one.
df <- read_csv (here::here("data", "data_sostf.csv"))

# import the metadata.
metadata <- here::here("survey", "data", "os_metadata_concerns.csv") %>% 
  read_csv(col_names = TRUE, skip_empty_rows = TRUE) %>% 
  filter(!is.na(OldVariable)) %>% 
  select(-c(MinValue:ImportID)) #does not import the extraneous variables
```

```{r demographics_ac_level, include=FALSE}

n <- length(df$ParticipantNumber)
valid_ac_level <- filter(df, AcLevel_Label != "NA")
nvalid_ac_level <- nrow(valid_ac_level)
per_ac_level <- perc(x = df$AcLevel_Label, y = nvalid_ac_level) 

```

# Overview

We conducted a survey in September 2019 to examine people's current use of open 
science practices, to examine their perceptions of these practices, and to examine
their perceived barriers to adopting these practices. Across the university, `r n` 
started the survey, although not all respondents completed all questions; thus, 
we report the sample size for each question. This document presents an overview 
of their responses. 

## Demographics: Academic Levels

In terms of respondents' demographic information, we did not collect information 
about gender or age to provide more anonymity to our respondents. We did, however,
ask about their Academic Level/Type and their Discpline (based on 2-digit and 
4-digit Field of Research [FOR] codes). Of the `r nrow(valid_ac_level)`
respondents who provided details about their Academic Level, `r per_ac_level [5]`%
were PhD students, `r per_ac_level [7]`% were Professors, and 
`r per_ac_level [10]`% were Senior Lecturers. The breakdown of the rest of the 
academic levels for the rest of the respondents are in the table below. 

```{r ac_level_table, echo=FALSE, warning=TRUE}

a2 <- valid_ac_level %>% 
  dplyr::count(AcLevel_Label) %>% 
   mutate (Percentage = round (n/nvalid_ac_level*100))

# specify the exact order of the columns based on AcLevels (select them according to the order
  # of the rows in the tibble)
a3 <-a2 [c(7,1,10,11,2,9,6,5,3,8,4),]

knitr::kable(a3, col.names = c("Academic Levels", "Frequency", "Percentage"), 
             caption = sprintf("Academic Levels of Respondents (n = %d)", 
                               nvalid_ac_level), align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```


```{r demographics_discipline, include=FALSE}

valid_disc <- filter(df, discipline != "Not Specified")
nvalid_disc <- nrow(valid_disc)
valid_per_disc <- perc(x = valid_disc$discipline, y = nvalid_disc) 
FOR_freq <- df %>% 
  select (FORcode_2_num, FORcode_2_label) %>% 
  dplyr::count(FORcode_2_num, FORcode_2_label) %>% 
  arrange(-desc(FORcode_2_num))

a <- colSums(FOR_freq[1:18,3])
```

## Demographics: Disciplines

In terms of Field of Research Codes, `r a` respondents classified themselves 
as belonging to one of the two-digit FOR codes from 01 to 20, one person indicated 
"Other", and `r FOR_freq[20,3]` respondents did not specify their FOR code. We 
did not have any responses from researchers in Earth Sciences (04), Agricultural 
and Veterinary Sciences (07), History and Archeology (21), and Philosophy and 
Religious Studies (22). 

%%% I RECKON I'LL MOVE THIS TO AN APPENDIX %%%

```{r FOR_table, echo=FALSE, warning=TRUE}

d2 <- df %>% 
  select (c(FORcode_2_num, FORcode_2_label)) %>% 
  dplyr::count(FORcode_2_num,FORcode_2_label) %>% 
  mutate (Percentage = round (n/nrow(df)*100))

# specify the exact order of the columns based on d2 (select them according to 
  # the order of the rows in the tibble)
# f2 <-d2 [c(12,16,3,8,1,9,7,20,13,2,6,5,4,19,17,11,18,10,15,14),]
  # I don't seem to be using this in this version, replaced with desc

dplyr::arrange(d2,-desc(FORcode_2_num)) %>% 
knitr::kable(col.names = c("FOR Code", "Field of Research Division", "Frequency",
                           "Percentage"), 
             caption = sprintf("Reported Two-Digit Field of Research Codes for Respondents (n = %d)", nrow(df)), align = 'clcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```


```{r FOR_table_by_role, echo=FALSE, warning=TRUE, eval = FALSE}

# Now look at how the data changes according to their academic level (student or not)
#  very few unspecified with students! Out of the 54 students, only 1 'other' and 1 'unspecified'
  # I don't need to use this either...CAN CUT THIS WHOLE CHUNK EVENTUALLY

student <- dplyr::filter(df, AcLevel_Label == "PhD Student" | 
                           AcLevel_Label == "Masters Student" | 
                           AcLevel_Label == "Research Assistant") %>% 
  dplyr::count(FORcode_2_num, FORcode_2_label)

dplyr::arrange(student,-desc(FORcode_2_num)) %>% 
knitr::kable(col.names = c("FOR Code", "Field of Research Division", "Frequency"),
             caption = sprintf("Reported Two-Digit Field of Research Codes for Student Respondents (n = %d)", (sum(student[3]))), align = 'clc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

# now showing the staff breakdown

staff <- dplyr::filter(df, AcLevel_Label == "Professor" |
                         AcLevel_Label == "Associate Professor" | 
                         AcLevel_Label == "Senior Lecturer" | 
                         AcLevel_Label == "Senior Research Fellow" | 
                         AcLevel_Label == "Lecturer" | 
                         AcLevel_Label == "Research Fellow" | 
                         AcLevel_Label == "Postdoc") %>% 
  dplyr::count(FORcode_2_num, FORcode_2_label)

dplyr::arrange(staff,-desc(FORcode_2_num)) %>% 
knitr::kable(col.names = c("FOR Code", "Field of Research Division", "Frequency"),
             caption = sprintf("Reported Two-Digit Field of Research Codes for Staff Respondents (n = %d)", (sum(staff[3]))), align = 'clc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

# now showing for respondents who did not specify their academic levels (NA or 'other')

unknown <- dplyr::filter(df, is.na(AcLevel_Label) | 
                           AcLevel_Label == "Other") %>% 
  dplyr::count(FORcode_2_num, FORcode_2_label)

dplyr::arrange(unknown,-desc(FORcode_2_num)) %>% 
knitr::kable(col.names = c("FOR Code", "Field of Research Division", "Frequency"), caption = sprintf("Reported Two-Digit Field of Research Codes for Unknown Academic Levels (n = %d)",(sum(unknown[3])))) %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```

For ease of interpretation and to reduce the identifiability of the respondents, 
for the FOR divisions with a small number of respondents (less than 10), we
combined similar divisions into disciplinary groups. Specifically, the new 
discipline grouping of Arts, Social Sciences, and Humanities (ASSH) included 
Education (FOR = `r FOR_freq[11,1]`, <em>n</em> = `r FOR_freq[11,3]`); Studies 
in Human Society (FOR = `r FOR_freq[14,1]`, <em>n</em> = `r FOR_freq[14,3]`); 
Studies in Creative Arts and Writing (FOR = `r FOR_freq[17,1]`, <em>n</em> =
`r FOR_freq[17,3]`); and Language, Communication and Culture (FOR = 
`r FOR_freq[18,1]`, <em>n</em> = `r FOR_freq[18,3]`). The new discipline grouping
of Business & Law included Economics (FOR = `r FOR_freq[12,1]`, <em>n</em> = 
`r FOR_freq[12,3]`); Commerce, Management, Tourism and Services (FOR = 
`r FOR_freq[13,1]`, <em>n</em> = `r FOR_freq[13,3]`), and Law and Legal Studies
(FOR = `r FOR_freq[16,1]`, <em>n</em> = `r FOR_freq[16,3]`). 
The new discipline grouping of Technology & Computer Sciences included Information
and Computing Sciences (FOR = `r FOR_freq[6,1]`, <em>n</em> = `r FOR_freq[6,3]`),
and Technology (FOR = `r FOR_freq[8,1]`, <em>n</em> = `r FOR_freq[8,3]`). We 
allocated Built Environment and Design (FOR = `r FOR_freq[10,1]`, <em>n</em> = 
`r FOR_freq[10,3]`) to the "Other" category. 
  
We retained the FOR divisions of Engineering (FOR = `r FOR_freq[7,1]`, <em>n</em> 
= `r FOR_freq[7,3]`); Medical and Health Sciences (FOR = `r FOR_freq[9,1]`,
<em>n</em> = `r FOR_freq[9,3]`); Physical Sciences (FOR = `r FOR_freq[2,1]`,
<em>n</em> = `r FOR_freq[2,3]`); and Psychology and Cognitive Sciences (FOR = 
`r FOR_freq[15,1]`, <em>n</em> = `r FOR_freq[15,3]`) as their own discipline 
groupings. The breakdown for the number of respondents according to discpline 
groupings is displayed in the next table.
  
<em>I AM SURE YOU WILL ALL AGREE THAT WE DON'T NEED THESE TWO PARAGRAPHS IN THE 
MAIN TEXT, BUT LEAVING IT FOR NOW TO MAKE SURE WE UNDERSTAND HOW EVERYTHING WAS 
GROUPED TOGETHER.</em> :)

```{r discipline_table, echo=FALSE, warning=TRUE}

d2 <- df %>% 
  dplyr::count(discipline) %>% 
   mutate (Percentage = round (n/nrow(df)*100))

# specify the exact order of the columns based on d3 (select them according to the order
  # of the rows in the tibble)
d3 <-d2 [c(4,8,10,3,5,1,2,9,7,6),]

d3 %>% 
knitr::kable(col.names = c("Disciplines", "Frequency", "Percentage"), 
             caption = sprintf("Discipline Groupings of Respondents (n = %d)",nrow(df)), 
              align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

# grouping the stem & non-stem disciples together in a new variable
df <- df %>% 
  mutate (assh = ifelse 
          (discipline %in% c ("Business & Law", "ASSH"), "ASSH", "STEM"))

```
  
```{r crisis_by_estimate, include = FALSE}

# filter rows with valid responses 
valid_rep_est <- filter(df, RepEstimate != "NA")

# calculate number of rows with a valid response 
nvalid_rep_est <- nrow(valid_rep_est)

# filter rows with valid responses for CRISIS & rename variable accordingly
nvalid_crisis <- filter(df, crisis != "NA") %>% 
  nrow()


per_crisis <- perc(x = df$crisis, y = nvalid_crisis)  #percentage per level 
# divided by number of valid cases for the crisis variable

# output of `per_crisis` inserted in text below
```

## Estimates of Reproducibility by Perceived Crisis  

Participants were asked if they believed their field is experiencing a
"reproducibility crisis". Of the `r nvalid_crisis` respondents who answered this 
question, `r per_crisis[1]`% indicated that they didn't know if there was a crisis, 
`r per_crisis[2]`% indicated there was no crisis, `r per_crisis[4]`% indicated that 
there was a slight crisis, and `r per_crisis[3]`% that there was a significant 
reproducibility crisis in their field.   

Participants were also asked to estimate the percentage of research publications 
their field that are reproducible. In the figure below, we plotted participants' 
reproducibility estimates according to their responses to the perceived 
crisis in their field. The black bar is the mean estimate of reproducibility 
perceived crisis. 

```{r crisis_by_estimate_stripchart, echo = FALSE, include = TRUE}

#estimates of reproducibility by levels of crisis as a stripchart 

title = sprintf("Estimates of reproducibility by perceived crisis in field (n = %d)",nvalid_rep_est)
x_name = "Do you think your field is experiencing a 'Reprodubility Crisis'?"
x_labels = c("Don't Know", "No Crisis", "Slight Crisis", "Significant Crisis")
y_name = "Estimated % of reproducible studies"

p <- ggplot(data = valid_rep_est, 
       aes(x=crisis, y=RepEstimate)) + 
  geom_jitter(position=position_jitter(height=0,width=.15),
              fill="blue",
              colour="blue",
              size = 2.2,
              alpha=.5) +
  stat_summary(fun.y=mean,
               fun.ymin=mean,
               fun.ymax=mean,
               geom='crossbar',
               width=0.5) +
  scale_x_discrete(name = x_name, limits = x_labels) +
  scale_y_continuous(name = y_name) +
  coord_cartesian(ylim = c(0,100)) +
  theme_classic (base_size = 12) +
  ggtitle(title)

p

# code to save it in the figs folder. Increase 'base_size' from 12 to 18 for slides. 
# ggsave(here::here("figs", "reprod_estimates_by_crisis.png"), plot = p)
```
  
   
## Experience with Open Science Practices

  
### Overall Experience with Open Science Practices

```{r os_experience, include = FALSE, warning=TRUE}

# filter rows with valid response for this variable & rename variable accordingly

valid_os_exp <- filter(df, OverallExp != "NA")

# calculate number of rows with a valid response for this variable
nvalid_os_exp <- nrow(valid_os_exp)

# create tibble with frequencies & percentages 

os_exp <- valid_os_exp %>% 
  dplyr::count(OverallExp) %>% 
  mutate(Percentage = round (n/(nrow(valid_os_exp))*100)) %>% 
  dplyr::arrange(desc(n))

```

Before we asked participants about their experience with open science practices, 
we explained that the practices enveloped by the umbrella term of "open science" 
were study preregistration, open materials and/or code, open data, pre-publication
archiving, and open access publishing.   

The figure below shows participants' experience with open science practices in
general. Of the `r nvalid_os_exp` participants who answered this question, 
`r os_exp[3,2]` (`r os_exp[3,3]`%) reported that they were unaware of open 
science practices; `r os_exp[1,2]` (`r os_exp[1,3]`%) reported that they were 
aware of open science practices, but had not used them; `r os_exp[2,2]` 
(`r os_exp[2,3]`%) reported that they had some experience with open science
practices; and only `r os_exp[4,2]` (`r os_exp[4,3]`%) reported that they had
extensive experience with open science practices. 

```{r os_experience_bar, echo=FALSE, warning=TRUE, eval = FALSE}

title = sprintf("Experience with open science practices (n = %d)",nvalid_os_exp)
x_name = "What is your experience with open science practices?"
x_labels = c("Unaware", "Aware, But Not Used", "Some Experience", "Extensive Experience")
y_name = "Frequency"

p <- ggplot(data = valid_os_exp, 
       aes(x = OverallExp)) + 
  geom_bar(
  colour = "black" , 
  fill = "blue") +
  scale_x_discrete(name = "What is your experience with open science practices?",
                   limits=c("Unaware", "Aware, But Not Used", "Some", "Extensive")) + 
  theme_classic(base_size = 12) +
  scale_y_continuous(name = "Frequency") +
  coord_cartesian(ylim = c(0,100)) +
  ggtitle(title)
p

# ggsave(here::here("figs", "os_overallexp_bar.png"))



```


```{r os_experience_pie, echo = FALSE}

title = "What is your experience with open science practices? (n = %d)"

# pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(the_data = df, label_var = "OverallExp",
                      the_title = title, 
                      colours,
                      the_quantity = "percent")
p
```

```{r tables_os_experience, echo = FALSE, eval = TRUE}

tb_os_exp <-os_exp [c(3,1,2,4),] # rearrange the responses

tb_os_exp %>% 
knitr::kable(col.names = c("Reported Experience", "Frequency", "Percentage"), 
             caption = sprintf("Overall Experience with Open Science Practices (n = %d)",
                               nvalid_os_exp), align = 'lcc')  %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

# the align parameter changes how the columns are aligned. l = left; c = centre

```

### Experience with different types of open science practices
   
Next, we break down the results according to their experience with specific types 
of open science practices. 

#### Study Preregistration

We defined study preregistration for our participants as: "Documenting and submitting
to a journal or public repository one's research questions, methodological design, 
and anlysis plan prior to analysing the data. This time-stamped document is made
openly available by the time the research is published so that any deviation from 
the original research plan is visible to the scientific community."

##### Perceived Importance of Preregistration 

```{r prereg_imp_count, echo = FALSE, warning=TRUE}

# filter rows with valid responses for this variable; first df contains all valid 
  # responses; the second df contains all valid responses, except 
  # "Researchers in my discipline...do not conduct research studies"

valid_prereg_imp <- filter(df, PreRegImp != "NA")
valid_prereg_imp_ex <- filter(valid_prereg_imp, PreRegImp != "Researchers in my discipline do not conduct research studies")

# calculate number of rows with a valid response for these variables
nvalid_prereg_imp <- nrow(valid_prereg_imp)
nvalid_prereg_imp_ex <- nrow(valid_prereg_imp_ex)

# create a tibble with frequency & percentage for all who answered question
tb <- valid_prereg_imp %>% 
  dplyr::count(PreRegImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_prereg_imp))*100)) %>% 
  dplyr::arrange(desc(n))

# create a tibble with frequency & percentage for data excluding "do not use"
tb_ex <- valid_prereg_imp_ex %>% 
  dplyr::count(PreRegImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_prereg_imp_ex))*100)) %>% 
  dplyr::arrange(desc(n))

```

We first asked participants how important preregistration of studies is for their field. 
Of the `r nvalid_prereg_imp` participants who answered this question, a small percentage 
(`r tb[5,3]`%) indicated that researchers in their discipline do not conduct 
research studies. As such, we excluded them from this analysis. Of the remaining 
`r nvalid_prereg_imp_ex` respondents, `r tb_ex[3,2]` (`r tb_ex[3,3]`%) indicated that 
preregistration was extremely important for their field; `r tb_ex[1,2]` (`r tb_ex[1,3]`%)
indicated that it was somewhat important; `r tb_ex[4,2]` (`r tb_ex[4,3]`)% indicated 
that preregistration was somewhat unimportant; and `r tb_ex[2,2]` (`r tb_ex[2,3]`%)
indicated that it was not at all important for their field. 

```{r prereg_imp_ex_pie_chart, echo = FALSE, warning = TRUE}

title = "Perceived Importance of Preregistration (n = %d)"

# pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(the_data = valid_prereg_imp_ex, label_var = "PreRegImp", 
                      the_title = title, 
                      colours,the_quantity = "percent")
p
```

```{r prereg_imp_ex_table, echo=FALSE, warning=TRUE}

tb_ex2 <- tb_ex [c(2,4,1,3),]  # rearrange the responses

tb_ex2 %>% 
knitr::kable (col.names = c("Perceived Importance", "Frequency",
                            "Percentage"), 
              caption = 
                sprintf("Perceived Importance of Preregistration <br> (n = %d)",
                                nvalid_prereg_imp_ex), 
              align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```

##### Experience with Study Preregistration

```{r prereg_exp_count, echo = FALSE, warning=TRUE}
# filter rows with valid responses for this variable
valid_prereg_exp <- filter(df, PreRegExp != "NA")

# calculate number of rows with a valid response for this variable
nvalid_prereg_exp <- nrow(valid_prereg_exp)

# create a tibble with frequency & percentage for all who answered question
tb <- valid_prereg_exp %>% 
  dplyr::count(PreRegExp) %>% 
  mutate(Percentage = round (n/(nrow(valid_prereg_exp))*100)) %>% 
  dplyr::arrange(desc(n))

```

We then asked respondents about their own experience with study preregistration. 
Of the `r nvalid_prereg_exp` participants who answered this question, `r tb[1,2]`
 (`r tb[1,3]`%) were unaware of study preregistration; `r tb[2,2]` (`r tb[2,3]`%) 
were aware of study preregistration, but had not used it; `r tb[3,2]` (`r tb[3,3]`%) 
had some experience with it, but did not regularly preregister their studies; and 
`r tb[4,2]` (`r tb[4,3]`%) regularly preregister their studies. 

```{r prereg_exp_pie_chart, echo = FALSE, warning = TRUE}

title = "What is your experience with preregistration? (n = %d)"

# pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(the_data = df, label_var = "PreRegExp", 
                      the_title = title, 
                      colours,the_quantity = "percent")
p
rm(title)
```

```{r prereg_exp_table, echo=FALSE, warning=TRUE}

# change the label for Regular Use
tb$PreRegExp <- tb$PreRegExp %>% 
  mapvalues(
    c("Unaware", "Aware, But Not Used", "Some Experience", "Reg Use"), 
    c("Unaware", "Aware, But Not Used", "Some Experience", "Regular Use"))

tb2 <- tb[c(1,2,3,4),] #fix order

tb2 %>% 
knitr::kable (col.names = c("Reported Experience", "Frequency", "Percentage"),
              caption = sprintf("Experience with Study Preregistration <br>(n = %d)",
                                nvalid_prereg_exp), 
              align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```

##### Concerns about Preregistration 

```{r prereg_concerns_data, echo=FALSE, warning=TRUE}

# wrangle the concern data so it's in long form & only includes endorsements.

PreRegCon_long <- df %>% 
     select(c("ParticipantNumber", 
              "PreRegCon_delay", 
              "PreRegCon_look", 
              "PreRegCon_prevent_exp", 
              "PreRegCon_stifle_creativity", 
              "PreRegCon_scooping", 
              "PreRegCon_prevent_sig", 
              "PreRegCon_diff_pub", 
              "PreRegCon_no_con")) %>%  
     pivot_longer(c("PreRegCon_delay", 
                    "PreRegCon_look", 
                    "PreRegCon_prevent_exp", 
                    "PreRegCon_stifle_creativity", 
                    "PreRegCon_scooping", 
                    "PreRegCon_prevent_sig", 
                    "PreRegCon_diff_pub", 
                    "PreRegCon_no_con"), 
     names_to = "PreRegConcern", 
     values_to = "PreReg_Endorsement") %>% 
  filter(PreReg_Endorsement == "1")  

# recode the data so the response options have proper labels
  # create a character vector with proper labels
prereg_con_key <- c (PreRegCon_delay = "Delays data collection", 
                     PreRegCon_look = "Need to look at data to analyse it",
                     PreRegCon_prevent_exp = "Prevents exploratory research",
                     PreRegCon_stifle_creativity = "Stifles creativity", 
                     PreRegCon_scooping = "Risk of scooping", 
                     PreRegCon_prevent_sig = "More difficult to find significant results",
                     PreRegCon_diff_pub = "More difficult to publish in certain journals", 
                     PreRegCon_no_con = "No concerns")

  # recode the values with this character vector 
PreRegCon_long$PreRegConcern <- recode(PreRegCon_long$PreRegConcern, !!!prereg_con_key)

# getting a tibble for the counts
c_prereg_con <- plyr::count(PreRegCon_long$PreRegConcern)

# to figure out how many respondents shared concerns calculate unique number of participants
n_prereg_con <- length(unique(PreRegCon_long$ParticipantNumber))

# create a tibble with percentages (of respondents who answered this question) & 
  # then reorder them by descending percentages

tb <- PreRegCon_long %>% 
  dplyr::count(PreRegConcern) %>% 
  mutate(Percentage = round (n/n_prereg_con*100)) %>% 
  dplyr::arrange(desc(n))

```

We also asked respondents if they have any concerns about preregistering their 
studies. After asking respondents to share their concerns in a free text format, 
we then provided a list of possible concerns that researchers could have about
preregistering their studies. 

Respondents were able to select as many concerns as they liked. Of the `r n_prereg_con`
respondents who answered this question, `r tb [7,2]` (`r tb [7,3]`%) 
reported that they do not share any of the listed concerns. The following figure 
presents, of those who answered this question, the percentage who selected 
each of the concerns.  

```{r prereg_concerns_bar, echo=FALSE, warning=TRUE}

# reorder the response options from lowest to highest, with concerns last
tb2 <- tb %>% 
  dplyr::mutate(PreRegConcern = factor (PreRegConcern, 
                                levels = c("More difficult to find significant results", 
                                           "More difficult to publish in certain journals", 
                                           "Delays data collection", 
                                           "Stifles creativity",  
                                           "Prevents exploratory research", 
                                           "Need to look at data to analyse it", 
                                           "Risk of scooping", 
                                           "No concerns")))

# create a character vector for the colours for each bar
cols <- c("lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "grey50")

# build the bar chart
title = sprintf("Concerns about preregistering studies\n (n = %d)", n_prereg_con)

# plot the reordered data and colours. Because the data is in a tibble rather than 
  # a dataframe with counts, I could use 'geom_col' rather than 'geom_bar' 
  # (or I could use stat = "identity" with 'geom_bar')

p <- ggplot(tb2) + 
  aes(x = PreRegConcern, y = Percentage) +
   geom_bar(stat = "identity", colour = "black", fill = cols) +
    labs (x = element_blank(),
      y = "Percentage", 
        title = title) +
  coord_flip(ylim = c(0,60)) +
  theme_classic(base_size = 12) + 
  theme(plot.title = element_text(hjust = 0.5)) 
p

```

#### Open Materials and/or Code 

The next section of the survey related to the use of open materials and/or code. 
For our purposes, we explained that open materials and/or code referred to researcher-
created resources used while collecting or analyzing data (e.g., survey questions, 
video stimuli, vignettes, algorithms, coding schemes, analytic code, etc.) that 
are made openly available to the research community.

##### Perceived Importance of Open Materials and/or Code 

```{r code_imp_count, echo = FALSE, warning=TRUE}

# filter rows with valid responses for this variable; first df contains all valid 
  # responses the second df contains all valid responses, except "Researchers...do 
  # not use materials and/or code "

valid_code_imp <- filter(df, CodeImp != "NA")
valid_code_imp_ex <- filter(valid_code_imp, CodeImp != "Researchers in my discipline do not use materials and/or code")

nvalid_code_imp <- nrow(valid_code_imp)
nvalid_code_imp_ex <- nrow(valid_code_imp_ex)

# create a tibble with frequency & percentage for all who answered question
tb <- valid_code_imp %>% 
  dplyr::count(CodeImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_code_imp))*100)) %>% 
  dplyr::arrange(desc(n))

# create a tibble with frequency & percentage for data excluding "do not use"
tb_ex <- valid_code_imp_ex %>% 
  dplyr::count(CodeImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_code_imp_ex))*100)) %>% 
  dplyr::arrange(desc(n))

```

We first asked participants how important they thought it was for their field to
make materials and/or code openly available. Of the `r sum(tb[2])` participants 
who answered this question, a small percentage (`r tb[5,3]`%) indicated 
that researchers in their discipline do not use materials and/or code. As such, 
we excluded them from this analysis. Of the remaining `r sum(tb_ex[2])` 
respondents, `r tb_ex[2,3]`% indicated that open materials and/or code were 
extremely important for their field; `r tb_ex[1,3]`% indicated that they were 
somewhat important; `r tb_ex[3,3]`% indicated that they were somewhat unimportant; 
and `r tb_ex[4,3]`% indicated that open materials and/or code were not at all 
important for their field. 


```{r code_imp_ex_pie_chart, echo = FALSE, warning = TRUE}

title = "Perceived importance of open materials and/or code (n = %d)"

# pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(the_data = valid_code_imp_ex, 
                      label_var = "CodeImp", 
                      the_title = title, 
                      colours,the_quantity = "percent")
p
```

```{r code_imp_ex_table, echo=FALSE, warning=TRUE}

tb_ex <- valid_code_imp_ex %>% 
  dplyr::count(CodeImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_code_imp_ex))*100)) %>% 
  dplyr::arrange(desc(n))

tb_ex2 <-tb_ex [c(4,3,1,2),] # rearrange the responses

tb_ex2 %>% 
knitr::kable (col.names = c("Perceived Importance", "Frequency", "Percentage"), 
              caption = sprintf("Perceived Importance of Open Materials and/or Code (n = %d)", nvalid_code_imp_ex), 
              align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```


##### Experience with Open Materials and/or Code

```{r code_count_exp, echo=FALSE, warning=TRUE}

# filter rows with valid responses for this variable
valid_code_exp <- filter(df,CodeExp != "NA")

# calculate number of rows with a valid response for this variable
nvalid_code_exp <- nrow(valid_code_exp)

tb <- valid_code_exp %>% 
  dplyr::count(CodeExp) %>%  
    mutate(Percentage = round (n/nvalid_code_exp*100)) %>% 
    dplyr::arrange(desc(n))

```

The following section shows how many people have experience with open code 
and/or materials. Of the `r nvalid_code_exp` participants who answered this 
question, `r tb[1,2]` (`r tb[1,3]`%) reported that, until now, they hadn't heard 
of open materials and/or code; `r tb[2,2]` (`r tb[2,3]`%) were aware of open
materials and/or code, but had not used it in their own research; `r tb[3,2]` 
(`r tb[3,3]`%) had some experience with open materials and/or code, but do not use
them regularly; and `r tb[4,2]` (`r tb[4,3]`%) regularly use open materials and/or
code. 

```{r code_exp_pie, echo = FALSE, warning = TRUE}

title = "What is your experience with open materials and/or code (n = %d)"

#pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(df,label_var="CodeExp",the_title = title, colours = colours, the_quantity="percent")
p
```


```{r code_exp_table, echo=FALSE, warning=TRUE}

tb2 <- tb [c(2,1,3,4),] # fix the order of responses

tb2 %>% 
knitr::kable (col.names = c("Reported Experience", "Frequency", "Percentage"), 
              caption = sprintf("Experience with Open Materials and/or Code (n = %d)",
                                nvalid_code_exp), align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```

For those participants who reported that they use open materials and/or code 
(that is, those who reported some use or regular use), we asked them for more 
information about how they use open materials and/or code. 'CODE USE'

<em> THIS NEEDS TO BE COMPLETED </em>

##### Concerns about Open Materials and/or Code

```{r code_concerns_data, echo=FALSE, warning=TRUE}

# wrangle this data so it's in long form & only includes endorsements.

CodeCon_long <- df %>% 
  select (c("ParticipantNumber", 
            "CodeCon_criticise", 
            "CodeCon_diff_understand", 
            "CodeCon_assistance", 
            "CodeCon_lose_control", 
            "CodeCon_errors", 
            "CodeCon_credit", 
            "CodeCon_no_con", 
            "CodeCon_violate", 
            "CodeCon_ip", 
            "FORcode_2_label")) %>%  
  pivot_longer(c("CodeCon_criticise", 
                 "CodeCon_diff_understand", 
                 "CodeCon_assistance", 
                 "CodeCon_lose_control", 
                 "CodeCon_errors", 
                 "CodeCon_credit", 
                 "CodeCon_no_con", 
                 "CodeCon_violate", 
                 "CodeCon_ip"), 
               names_to = "CodeConcern", 
               values_to = "CodeCon_Endorsement") %>% 
  filter(CodeCon_Endorsement == "1")

# recode the data so the response options have proper labels
  # create a character vector with proper labels
code_con_key <- c (CodeCon_criticise = "Others might criticise my materials/code", 
                     CodeCon_diff_understand = "Others might find it difficult to understand my materials/code",
                     CodeCon_assistance = "Others might ask for my assistance with their research",
                     CodeCon_lose_control = "I might lose control over how they are used", 
                     CodeCon_errors = "Others might find errors in my published work", 
                     CodeCon_credit = "I might not receive appropriate credit",
                     CodeCon_violate = "Reuse could violate epistemological framework", 
                     CodeCon_ip = "Issues related to intellectual property", 
                     CodeCon_no_con = "No concerns")
 
 # recode the values with this character vector
CodeCon_long$CodeConcern <- recode(CodeCon_long$CodeConcern, !!!code_con_key)

# getting a tibble for the counts
c_code_con <- plyr::count(CodeCon_long$CodeConcern)

# to figure out how many respondents shared concerns calculate unique number of participants
n_code_con <- length(unique(CodeCon_long$ParticipantNumber))

# create a tibble with percentages (of respondents who answered this question) & 
# then reorder them by descending percentages
tb <- CodeCon_long %>% 
  dplyr::count(CodeConcern) %>% 
  mutate(Percentage = round (n/n_code_con*100)) %>% 
  dplyr::arrange(desc(n))

```

We also asked respondents if they have any concerns about making their research 
materials and/or code open. After asking respondents to share their concerns in 
a free text format, we provided a list of possible concerns that researchers 
could have about sharing their materials and/or code. Respondents were able to 
select as many concerns as they liked. A total of `r n_code_con` respondents 
answered this question. Of those who respondended to this question,
`r tb [4,2]` (`r tb [4,3]`%) reported that they do not share any of the listed 
concerns. The following figure presents, of those who answered this question, 
the percentage who selected each of the concerns.  

```{r code_concerns_bar, echo=FALSE, warning=TRUE}
# build the bar chart

# reorder the response options from lowest to highest, with concerns last
tb2 <- tb %>% 
  dplyr::mutate(CodeConcern = factor (CodeConcern, 
                levels = c("Others might find errors in my published work", 
                         "Reuse could violate epistemological framework", 
                         "Others might ask for my assistance with their research", 
                         "Others might criticise my materials/code", 
                        "Others might find it difficult to understand my materials/code", 
                         "I might lose control over how they are used", 
                         "I might not receive appropriate credit", 
                         "Issues related to intellectual property", 
                         "No concerns")))
  # I don't get it. tb & tb2 look the same in the tibble, but the order is completely
  # different when they are graphed..

# create a character vector for the colours for each bar
cols <- c("lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", "grey50")

# build the bar chart
title = sprintf("Concerns about open materials\n and/or code (n = %d)", n_code_con)

# plot the reordered data and colours. Because the data is in a tibble rather than a     
  # dataframe with counts, I could use 'geom_col' rather than 'geom_bar'(or I 
  # could use stat = "identity" with 'geom_bar')

p <- ggplot(tb2) + 
  aes(x = CodeConcern, y = Percentage) +
  geom_bar(stat = "identity", colour = "black", fill = cols) +
  labs (x = element_blank(),
        y = "Percentage", 
        title = title) +
  coord_flip(ylim = c(0,60)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 50)) + #wrap the labels
  theme_classic(base_size = 12) + 
  theme(plot.title = element_text(hjust = 0.5)) # centre the title
p

```

#### Open Data

The next section of the survey related to the use of open data. 
For our purposes, we explained that open data can be defined as "online, free of 
cost, accessible data that can be used, reused and distributed provided that the 
data source is attributed and shared alike." [FIND SOURCE FROM SURVEY]

##### Perceived Importance of Open Data 

```{r data_imp_count, echo = FALSE, warning=TRUE}

# filter rows with valid responses for this variable; first df contains all valid 
  # responses the second df contains all valid responses, except "Researchers...do 
  # not use materials and/or code "

valid_data_imp <- filter(df, DataImp != "NA")
valid_data_imp_ex <- filter(valid_data_imp, DataImp != "Research publications in my field are not based on data")

nvalid_data_imp <- nrow(valid_data_imp)
nvalid_data_imp_ex <- nrow(valid_data_imp_ex)

# create a tibble with frequency & percentage for all who answered question
tb <- valid_data_imp %>% 
  dplyr::count(DataImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_data_imp))*100)) %>% 
  dplyr::arrange(desc(n))

# create a tibble with frequency & percentage for data excluding "do not use"
tb_ex <- valid_data_imp_ex %>% 
  dplyr::count(DataImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_data_imp_ex))*100)) %>% 
  dplyr::arrange(desc(n))

```

We first asked participants how important they thought it was for their field that 
data from published research are openly available. Of the `r sum(tb[2])` participants 
who answered this question, a small number `r tb[5,2]` (`r tb[5,3]`%) indicated that
`r tolower(tb[5,1])`. As such, we excluded them from this analysis. Of the 
remaining `r sum(tb_ex[2])` respondents, `r tb_ex[1,2]` (`r tb_ex[1,3]`%) indicated 
that open data were `r tolower(tb_ex[1,1])` for their field; `r tb_ex[2,2]` 
(`r tb_ex[2,3]`%) indicated that they were `r tolower(tb_ex[2,1])`; `r tb_ex[3,2]` 
(`r tb_ex[3,3]`%) indicated that they were `r tolower(tb_ex[3,1])`; 
and `r tb_ex[4,2]` (`r tb_ex[4,3]`%) indicated that open data were `r tolower(tb_ex[4,1])` 
important for their field. 

```{r data_imp_ex_pie_chart, echo = FALSE, warning = TRUE}

title = "Perceived importance of open data (n = %d)"

# pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(the_data = valid_data_imp_ex, 
                      label_var = "DataImp", 
                      the_title = title, 
                      colours,the_quantity = "percent")
p
```

```{r data_imp_ex_table, echo=FALSE, warning=TRUE}

tb_ex <- valid_data_imp_ex %>% 
  dplyr::count(DataImp) %>% 
  mutate(Percentage = round (n/(nrow(valid_data_imp_ex))*100)) %>% 
  dplyr::arrange(desc(n))

tb_ex2 <-tb_ex [c(4,3,2,1),] # rearrange the responses

tb_ex2 %>% 
knitr::kable (col.names = c("Perceived Importance", "Frequency", "Percentage"), 
              caption = sprintf("Perceived Importance of Open Data (n = %d)", nvalid_data_imp_ex), 
              align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```


##### Experience with Open Data

```{r data_count_exp, echo=FALSE, warning=TRUE}

# filter rows with valid responses for this variable
valid_data_exp <- filter(df,DataExp != "NA")

# calculate number of rows with a valid response for this variable
nvalid_data_exp <- nrow(valid_data_exp)

tb <- valid_data_exp %>% 
  dplyr::count(DataExp) %>%  
    mutate(Percentage = round (n/nvalid_data_exp*100)) %>% 
    dplyr::arrange(desc(n))

```

We also asked participants about their experience with open data. Of the 
`r sum(tb[2])` participants who answered this question, `r tb[4,2]` (`r tb[4,3]`%) 
indicated that until now, they were unaware of open data; `r tb[1,2]` 
(`r tb[1,3]`%) indicated that they were were aware of open data, but had not used
it in their research; `r tb[2,2]` (`r tb[2,3]`%) indicated that they had some 
experience with open data, but did not use them regularly; and `r tb_ex[3,2]` 
(`r tb_ex[3,3]`%) indicated that they regularly use open data. 

```{r data_exp_pie, echo = FALSE, warning = TRUE}

title = "What is your experience with open data? (n = %d)"

#pie chart
colours <- brewer.pal(4, "Blues")
p <- simple_pie_chart(df,label_var="DataExp",the_title = title, colours = colours, the_quantity="percent")
p
```


```{r data_exp_table, echo=FALSE, warning=TRUE}

tb2 <- tb [c(4,1,2,3),] # fix the order of responses

tb2 %>% 
knitr::kable (col.names = c("Reported Experience", "Frequency", "Percentage"), 
              caption = sprintf("Experience with Open Data (n = %d)",
                                nvalid_data_exp), align = 'lcc') %>% 
   kable_styling(bootstrap_options = "striped", full_width = F, 
                 position = 'center',
                latex_options = "hold_position")
# html output = font_size = 14 # insert in kable styling

```

For those participants who reported that they use open data 
(that is, those who reported some use or regular use), we asked them for more 
information about how they use open data. 'DATA USE' ...
<em> THIS NEEDS TO BE COMPLETED IF WE WANT IT </em>

##### Concerns about Open Data

```{r data_concerns_data, echo=FALSE, warning=TRUE, eval = TRUE}

# wrangle this data so it's in long form & only includes endorsements.

DataConcern_long <- df %>% 
  select (c("ParticipantNumber", 
            "DataConcern_criticise":"DataConcern_scoop",
            "FORcode_2_label")) %>%  
  select(-"DataConcern_text") %>% 
  pivot_longer(c("DataConcern_criticise":"DataConcern_scoop"),
               names_to = "DataConcern", 
               values_to = "DataConcern_Endorsement") %>% 
  filter(DataConcern_Endorsement == "1")

# recode the data so the response options have proper labels

b <- DataConcern_long
c <- metadata %>% 
    filter(NewVariable != "DataConcern_text") #remove this value from metadata

d <- full_join(b, c, by = c("DataConcern" = "NewVariable")) %>% 
  rename ("DataConcern_text" = "ItemTextShort")

# getting a tibble for the counts
c_data_con <- plyr::count(d$DataConcern)

# to figure out how many respondents shared concerns calculate unique number of participants
n_data_con <- length(unique(d$ParticipantNumber))

# create a tibble with percentages (of respondents who answered this question) & 
# then reorder them by descending percentages
tb <- d %>% 
  dplyr::count(DataConcern_text) %>% 
  mutate(Percentage = round (n/n_data_con*100)) %>% 
  dplyr::arrange(desc(n)) 
 # mutate_if(is.character, ~factor(.)) # make it a factor

d2 <- d %>% # create tibble with the Data Concern counts
  select(DataConcern, DataConcern_text)  %>% 
      dplyr::count(DataConcern) 
  #  mutate_if(is.character, ~factor(.))

# join the two tables together
tb2 <- left_join(x = tb, y = d2, by = "n") 
```

We also asked respondents if they have any concerns about making their data open.
After asking respondents to share their concerns in a free text format, we 
provided a list of possible concerns that researchers could have about sharing 
their data. Respondents were able to select as many concerns as they liked. 
A total of `r n_data_con` respondents answered this question. Of those who respondended,
`r tb2 [11,2]` (`r tb2 [11,3]`%) reported that they do not share any of the listed 
concerns. The following figure presents, of those who answered this question, 
the percentage who selected each of the concerns.  

```{r data_concerns_bar, echo=FALSE, warning=TRUE, eval=TRUE}

# build the bar chart

# reorder the rows according to the DataConcern_text 
tb3 <- tb2 %>% 
  dplyr::mutate(DataConcern_text = factor(DataConcern_text, 
                levels = c("Other", 
                           "It devalues research data collection", 
                           "Unfair for other researchers to benefit from my data collection", 
                          "Others might criticise my data and/or research practices", 
                           "Too much time or effort", 
                           "I might lose control over how my data are being used",
                           "I might not receive appropriate credit for my data collection", 
                           "Others could use my data for another study that I intended to conduct in the future", 
                           "Issues related to intellectual property", 
                           "Issues related to privacy", 
                           "Issues related to ethics", 
                           "No concerns")))



# create a character vector for the colours for each bar
cols <- c("lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "grey50")

                    
# build the bar chart
title = sprintf("Concerns about open data (n = %d)", n_data_con)

p <- ggplot(tb3) + 
  aes(x = DataConcern_text, y = Percentage) +
  geom_bar(stat = "identity", colour = "black", fill = cols) +
  labs (x = element_blank(),
        y = "Percentage", 
        title = title) +
  coord_flip(ylim = c(0,60)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 50)) + #wrap the labels
  theme_classic(base_size = 12) + 
  theme(plot.title = element_text(hjust = 0.5)) # centre the title
p

```

```{r data_concerns_bar_play, echo=FALSE, warning=TRUE, eval=FALSE}
# build the bar chart

# reorder the rows according to the DataConcern (because it has less text)
tb3 <- tb2 %>% 
  dplyr::mutate(DataConcern = factor(DataConcern, 
                                     levels = c("DataConcern_other", 
                                                "DataConcern_devalues",
                                                "DataConcern_unfair", 
                                                "DataConcern_criticise",
                                                "DataConcern_effort", 
                                                "DataConcern_control",
                                                "DataConcern_credit",
                                                "DataConcern_scoop",
                                                "DataConcern_ip",
                                                "DataConcern_privacy",
                                                "DataConcern_ethics",
                                                "DataConcern_none"))) %>% 
  dplyr::mutate(DataConcern_text = factor(DataConcern_text)) #turn into factors


https://raw.githubusercontent.com/janhove/janhove.github.io/master/RCode/sortLvls.R

# HIS ORIGINAL CODE

sortLvls.fnc <- function(oldFactor, levelOrder) {
  if(!is.factor(oldFactor)) stop("The variable you want to reorder isn't a factor.")
  
  if(!is.numeric(levelOrder)) stop("'order' should be a numeric vector.")
  
  if(max(levelOrder) > length(levels(oldFactor))) stop("The largest number in 'order' can't be larger than the number of levels in the factor.")
  
  if(length(levelOrder) > length(levels(oldFactor))) stop("You can't have more elements in 'order' than there are levels in the factor.")
  
  if(length(levelOrder) == length(levels(oldFactor))) {
    reorderedFactor <- factor(oldFactor, levels = levels(oldFactor)[levelOrder])
  }
  
  if(length(levelOrder) < length(levels(oldFactor))) {
    levelOrderAll <- c(levelOrder, (1:length(levels(oldFactor)))[-levelOrder])
    reorderedFactor <- factor(oldFactor, levels = levels(oldFactor)[levelOrderAll])
  }
  
  return(reorderedFactor)
}

### ME PLAYING WITH IT! IT WORKS, in theory, BUT IT STILL DOESN'T FORCE GGPLOT TO USE THE TEXT

sortLvls.fnc <- function(oldFactor, levelOrderFctr) {
  if(!is.factor(oldFactor)) stop("The variable you want to reorder isn't a factor.")
  
  if(!is.factor(levelOrderFctr)) stop("The level variable you want to use isn't a factor.")
  
  if(length(levelOrderFctr) == length(levels(oldFactor))) {
    reorderedFactor <- factor(oldFactor, levels = levels(oldFactor)[levelOrderFctr])
  }
  
  return(reorderedFactor)
}

tb3$DataConcern_text_order <- sortLvls.fnc(oldFactor = tb3$DataConcern_text, levelOrderFctr = tb3$DataConcern)

# HIS ORIGINAL CODE

sortLvlsByVar.fnc <- function(oldFactor, sortingVariable, ascending = TRUE) {
  
  require("dplyr")
  require("magrittr")
  
  # Combine into data frame
  df <- data.frame(oldFactor, sortingVariable)
  
  ###
  ### If you want to sort the levels by, say, the median, sd etc. instead of the mean,
  ### just change 'mean(sortingVariable)' below to, say, 'median(sortingVariable)'.
  ###
  
  # Compute average of sortingVariable and arrange (ascending)
  if (ascending == TRUE) {
    df_av <- df %>% group_by(oldFactor) %>% summarise(meanSortingVariable = mean(sortingVariable)) %>% 
      arrange(meanSortingVariable)
  }
  
  # Compute average of sortingVariable and arrange (descending)
  if (ascending == FALSE) {
    df_av <- df %>% group_by(oldFactor) %>% summarise(meanSortingVariable = mean(sortingVariable)) %>% 
      arrange(desc(meanSortingVariable))
  }
  
  # Return factor with new level order
  newFactor <- factor(oldFactor, levels = df_av$oldFactor)
  return(newFactor)
}

caption <- tb3$DataConcern_text_order %>% (function(x) str_wrap(x, width = 50))


# create a character vector for the colours for each bar
cols <- c("lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "lightskyblue3", 
          "lightskyblue3", "lightskyblue3", "lightskyblue3", "grey50")

            
# build the bar chart
title = sprintf("Concerns about open data (n = %d)", n_data_con)

p <- ggplot(tb3) + 
  aes(x = DataConcern, y = Percentage) +
  geom_bar(stat = "identity", colour = "black", fill = cols) +
  labs (x = element_blank(),
        y = "Percentage", 
        title = title) +
  coord_flip(ylim = c(0,60)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 50)) + #wrap the labels
  theme_classic(base_size = 12) + 
  theme(plot.title = element_text(hjust = 0.5)) # centre the title
p

```

```{r skim df, eval=FALSE, include=FALSE}

# These are chunks from the course I took, that I'm keeping now just for reference
# As a quick first pass, we can use the 'skim()' function to get a simple overview of each variable:
#skim(df)

# Now learning about group_by which appears to be a wonderful development!

frames %>%
  group_by(test_item, sample_size, n_obs, condition) %>%
  summarise(response = mean(response)) %>% #can call "response" anything you want.
  ungroup() #get in this habit because otherwise you might retain the grouping elsewhere.


# Now playing around with it to include more summary statistics, and to print out the different summary stats in a tiblle.

frames %>%
  group_by(test_item) %>%
  summarise(
    mean_resp = mean(response),
    sd_resp = sd(response),
    count = n()
  ) %>%
  ungroup


# Now play with filter to get summary stats from just a subset of the sample (their responses to only the 'small' objects).

average_response <- frames %>%
  group_by(test_item, sample_size, n_obs, condition) %>%
  summarise(response = mean(response)) %>%
  ungroup ()

average_response %>%
  filter(sample_size == "small") #this is not changing the average response variable because it still has everything in it.

#Now play with arrange to get summary stats from just a subset of the sample (their responses to only the 'small' objects), and arrange by condition.

average_response <- frames %>%
  group_by (test_item, sample_size, n_obs, condition) %>%
  summarise (response = mean(response)) %>%
  ungroup ()

average_response %>%
  filter (sample_size == "small") %>%
  arrange (condition)

# Now play with select to build on filter & arrange, but to only show some of the columns.

average_response <- frames %>%
  group_by (test_item, sample_size, n_obs, condition) %>%
  summarise (response = mean(response)) %>%
  ungroup ()

average_response_small <- average_response %>%
  filter (sample_size == "small") %>%
  arrange (condition) %>%
  select (condition, test_item, response)

average_response_small

# Now use mutate to create a new variable, which takes into account how many trials they completed.

average_response_small <- average_response_small %>%
  mutate (generalisation = response/9) %>%
  select (-response) #now remove response because we don't need it any longer

average_response_small

```

```{r clean environment, echo = FALSE}
rm(a2)
rm(a3)
rm(os_exp)
rm(d2)
rm(d3)
rm(df)
rm(FOR_freq)
rm(n)
rm(nvalid_ac_level)
rm(nvalid_crisis)
rm(nvalid_disc)
rm(nvalid_os_exp)
rm(nvalid_rep_est)
```

